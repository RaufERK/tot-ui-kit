var r = Object.defineProperty;
var o = (i, t, e) => t in i ? r(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var a = (i, t, e) => o(i, typeof t != "symbol" ? t + "" : t, e);
import { AmountBaseInputParser as n } from "./AmountBaseInputParser.js";
import { AmountBaseInputFormatter as l } from "./AmountBaseInputFormatter.js";
class m {
  constructor(t, e) {
    /** Значение. */
    a(this, "value");
    /** Отформатированное значение. */
    a(this, "formattedValue");
    /** Положение каретки. */
    a(this, "caret");
    /** Максимальное количество знаков перед запятой. */
    a(this, "maxIntegerDigits");
    /** Количество чисел после запятой. */
    a(this, "fractionDigits");
    /** Кэш для хранения значений. */
    a(this, "cache");
    this.value = "", this.formattedValue = "", this.caret = 0, this.maxIntegerDigits = t, this.fractionDigits = e, this.cache = {
      formattedValue: "",
      key: "",
      selectionDirection: null,
      selectionEnd: null,
      selectionStart: null
    };
  }
  /** Применение входных данных. */
  apply(t, e) {
    this.parse(t, e), this.format(this.value);
  }
  /** Обработка значения. */
  parse(t, e) {
    const s = new n(this.maxIntegerDigits, this.fractionDigits);
    s.apply(t, e, this.cache.key), this.value = s.getValue(), this.caret = e + s.getCaretOffset();
  }
  /** Форматирование значения. */
  format(t) {
    const e = new l(this.maxIntegerDigits, this.fractionDigits);
    e.apply(t), this.formattedValue = e.getValue(), this.caret += e.getCaretOffset();
  }
}
export {
  m as AmountBaseInputCore
};
//# sourceMappingURL=AmountBaseInputCore.js.map
