var c = Object.defineProperty;
var h = (r, d, e) => d in r ? c(r, d, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[d] = e;
var s = (r, d, e) => h(r, typeof d != "symbol" ? d + "" : d, e);
import { jsx as N } from "react/jsx-runtime";
import { EVENT_KEY_CODES as u } from "../../utils/keyboard.js";
import l from "react";
import { TreeViewAbstractNodeUtils as i } from "./TreeViewAbstractNodeUtils.js";
import { TreeViewContext as m } from "./TreeViewContext.js";
import { TreeViewAbstractNode as C } from "./TreeViewAbstractNode.js";
import { TreeViewNode as f } from "./components/TreeViewNode.js";
import { TreeViewGroup as b } from "./components/TreeViewGroup.js";
import { c as v } from "../../chunks/vendor-Ba_pyhza.js";
const w = "rootNode";
class n extends l.Component {
  constructor(e) {
    super(e);
    s(this, "abstractRootNode");
    s(this, "treeNode", null);
    /**
     * Обработка изменения контекста.
     * Установка tabIndex={0} для первой ноды, и tabIndex={-1} для остальных.
     */
    s(this, "updateTabIndexNodes", () => {
      const e = this.abstractRootNode.getChildren();
      let t = !1;
      e.forEach((o, a) => {
        a === 0 && o.getTabIndex() !== 0 ? (o.setTabIndex(0), t = !0) : a !== 0 && o.getTabIndex() === 0 && (o.setTabIndex(-1), t = !0);
      }), t && this.setState(({ updateCount: o }) => ({ updateCount: o++ }));
    });
    /** Добавляет ноду в родительскую ноду. */
    s(this, "registerNode", (e, t, o, a) => {
      t.addChild(e, o, a), this.updateTabIndexNodes(), this.setState(({ updateCount: p }) => ({ updateCount: p++ }));
    });
    /** Удаляет ноду из родительской ноды. */
    s(this, "removeNode", (e) => {
      var t;
      (t = e.getParent()) == null || t.removeChild(e), this.updateTabIndexNodes();
    });
    /** Установка флага активности ноды. */
    s(this, "setActiveNode", (e, t) => {
      i.setActiveNode(e, this.abstractRootNode, t), this.setState(({ updateCount: o }) => ({ updateCount: o++ }));
    });
    /** Установка флага opened ноды. */
    s(this, "setOpenedNode", (e, t) => {
      e.setOpened(t), this.setState(({ updateCount: o }) => ({ updateCount: o++ }));
    });
    /** Возвращает AbstractNode по id. */
    s(this, "getNode", (e) => i.getNode(e, this.abstractRootNode));
    s(this, "setTreeDOMNode", (e) => this.treeNode = e);
    /** Обработка нажатия на клавиш для навигации с клавиатуры. */
    s(this, "handleKeyDown", (e) => {
      i.getActiveNode(this.abstractRootNode) && (u.ARROW_DOWN === e.keyCode ? (i.setActiveNextNode(this.abstractRootNode), e.preventDefault(), this.setState(({ updateCount: t }) => ({ updateCount: t++ }))) : u.ARROW_UP === e.keyCode && (i.setActivePrevNode(this.abstractRootNode), e.preventDefault(), this.setState(({ updateCount: t }) => ({ updateCount: t++ }))));
    });
    this.abstractRootNode = new C({ id: w }), this.state = {
      updateCount: 0
    };
  }
  componentDidMount() {
    window.addEventListener("keydown", this.handleKeyDown);
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleKeyDown);
  }
  render() {
    const { children: e, className: t, ...o } = this.props, { updateCount: a } = this.state;
    return /* @__PURE__ */ N(
      m.Provider,
      {
        value: {
          getNode: this.getNode,
          parentNode: this.abstractRootNode,
          registerNode: this.registerNode,
          removeNode: this.removeNode,
          rootNode: this.abstractRootNode,
          setActiveNode: this.setActiveNode,
          setOpenedNode: this.setOpenedNode,
          updateCount: a
        },
        children: /* @__PURE__ */ N("ul", { className: v("cssClass[treeView]", t), role: "tree", ...o, ref: this.setTreeDOMNode, children: e })
      }
    );
  }
}
s(n, "displayName", "TreeView"), s(n, "Node", f), s(n, "Group", b);
export {
  n as TreeView
};
//# sourceMappingURL=TreeView.js.map
