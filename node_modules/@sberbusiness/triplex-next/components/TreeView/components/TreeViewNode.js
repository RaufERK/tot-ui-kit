var p = Object.defineProperty;
var h = (r, d, e) => d in r ? p(r, d, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[d] = e;
var s = (r, d, e) => h(r, typeof d != "symbol" ? d + "" : d, e);
import { jsx as a } from "react/jsx-runtime";
import l from "react";
import { TreeViewContext as x, withTreeViewContext as b } from "../TreeViewContext.js";
import { TreeViewAbstractNode as m } from "../TreeViewAbstractNode.js";
import { TreeViewAbstractNodeUtils as n } from "../TreeViewAbstractNodeUtils.js";
import { c as w } from "../../../chunks/vendor-Ba_pyhza.js";
class C extends l.Component {
  constructor(e) {
    super(e);
    s(this, "containerDOMNode");
    // Абстрактная нода текущей ViewNode.
    s(this, "abstractNode");
    /**
     * Обработчик события blur.
     * Если нода была активна - становится неактивной.
     */
    s(this, "handleBlur", (e) => {
      const { onBlur: t, treeViewContext: o } = this.props;
      e.stopPropagation(), o.setActiveNode(this.abstractNode, !1), t == null || t(e);
    });
    /**
     * Обработчик события focus.
     * При всплытии фокуса до контейнера ноды - ноды становится активной.
     */
    s(this, "handleFocus", (e) => {
      const { onFocus: t, treeViewContext: o } = this.props;
      e.stopPropagation(), o.setActiveNode(this.abstractNode, !0), t == null || t(e);
    });
    s(this, "setContainerDOMNode", (e) => this.containerDOMNode = e);
    /** Устанавливает флаг opened ноды. */
    s(this, "setOpenedNode", () => (e) => {
      this.props.treeViewContext.setOpenedNode(this.abstractNode, e);
    });
    const { treeViewContext: t } = e;
    this.abstractNode = new m({ id: e.id }), t.setOpenedNode(this.abstractNode, !!e.opened);
    let o;
    e.prevNodeId && (o = n.getNode(e.prevNodeId, t.parentNode));
    let i;
    e.nextNodeId && (i = n.getNode(e.nextNodeId, t.parentNode)), t.registerNode(this.abstractNode, t.parentNode, o, i);
  }
  componentDidUpdate(e) {
    const { opened: t, treeViewContext: o } = this.props, { opened: i } = e;
    t !== i && o.setOpenedNode(this.abstractNode, !!t);
  }
  componentWillUnmount() {
    const { treeViewContext: e } = this.props;
    e.removeNode(this.abstractNode);
  }
  render() {
    const { children: e, className: t, nextNodeId: o, opened: i, prevNodeId: V, treeViewContext: N, ...c } = this.props;
    return /* @__PURE__ */ a(x.Provider, { value: { ...N, parentNode: this.abstractNode }, children: /* @__PURE__ */ a(
      "li",
      {
        role: "treeitem",
        tabIndex: this.abstractNode.getTabIndex(),
        "aria-expanded": this.abstractNode.getOpened(),
        className: w("cssClass[treeViewNode]", t),
        ...c,
        onBlur: this.handleBlur,
        onFocus: this.handleFocus,
        ref: this.setContainerDOMNode,
        children: e({
          activeNode: this.abstractNode.getActive(),
          hasChildNodes: !!this.abstractNode.getChildren().length,
          isLastNode: n.isLastNode(this.abstractNode),
          openedNode: this.abstractNode.getOpened(),
          setOpenedNode: this.setOpenedNode()
        })
      }
    ) });
  }
}
const A = b(C);
export {
  A as TreeViewNode,
  C as TreeViewNodeWithContext
};
//# sourceMappingURL=TreeViewNode.js.map
