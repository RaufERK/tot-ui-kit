var c = Object.defineProperty;
var d = (t, e, i) => e in t ? c(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var s = (t, e, i) => d(t, typeof e != "symbol" ? e + "" : e, i);
import { i as l } from "../../chunks/vendor-Ba_pyhza.js";
class u {
  constructor() {
    // Массив дочерних нод.
    s(this, "children", []);
    // Родительская нода.
    s(this, "parent", null);
    /** Возвращает дочерние ноды. */
    s(this, "getChildren", () => this.children);
    /** Добавляет дочернюю ноду к текущим. */
    s(this, "addChild", (e, i, r) => {
      if (e.setParent(this), i) {
        const h = this.children.findIndex((n) => l(n, i));
        this.children.splice(h + 1, 0, e);
      } else if (r) {
        const h = this.children.findIndex((n) => l(n, r));
        this.children.splice(h, 0, e);
      } else
        this.children.push(e);
    });
    /** Удаляет дочернюю ноду. */
    s(this, "removeChild", (e) => {
      const i = this.children.findIndex((r) => l(r, e));
      i > -1 && (this.children.splice(i, 1), e.setParent(null));
    });
    /** Устанавливает дочерние ноды вместо текущих дочерних нод. */
    s(this, "setChildren", (e) => {
      this.children.forEach((i) => i.setParent(null)), e.forEach((i) => i.setParent(this)), this.children = e;
    });
    /** Возвращает родительскую ноду. */
    s(this, "getParent", () => this.parent);
    /** Устанавливает родительскую ноду. */
    s(this, "setParent", (e) => {
      this.parent = e;
    });
  }
}
function a(t, e) {
  if (e(t) && t.getChildren().length)
    for (const r of t.getChildren())
      a(r, e);
}
export {
  u as AbstractTreeNode,
  a as traverseAbstractTree
};
//# sourceMappingURL=AbstractTreeNode.js.map
