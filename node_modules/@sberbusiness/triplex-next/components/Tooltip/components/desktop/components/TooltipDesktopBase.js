var _ = Object.defineProperty;
var H = (p, a, i) => a in p ? _(p, a, { enumerable: !0, configurable: !0, writable: !0, value: i }) : p[a] = i;
var t = (p, a, i) => H(p, typeof a != "symbol" ? a + "" : a, i);
import { jsxs as S, Fragment as P, jsx as x } from "react/jsx-runtime";
import O from "react";
import { i as M, c as $ } from "../../../../../chunks/vendor-Ba_pyhza.js";
import { TooltipContext as X } from "../../../TootlipContext.js";
import { Portal as Y } from "../../../../Portal/Portal.js";
import { ETooltipPreferPlace as u, ETooltipDirection as B, ETooltipAlign as z, ETooltipFlowTypes as I, ETooltipSizeParameter as r, ETooltipTypeName as C, ETooltipEndCoordinates as N, ETooltipStartCoordinates as R, ETooltipAxesType as G, ETooltipSize as U } from "../../../enums.js";
import { TooltipDesktopTip as V } from "./TooltipDesktopTip.js";
import { pickZone as j, axes as q, calcRelPos as K, centerOfBoundsFromBounds as Z, calcBounds as L, equalCoords as J } from "../../../utils/Positioning.js";
import { s as f } from "../../../../../chunks/TooltipDesktop.module-D72ObNia.js";
const Q = {
  column: "translateX",
  row: "translateY"
}, b = {
  column: "translateY",
  row: "translateX"
}, tt = {
  [u.ABOVE]: B.DOWN,
  [u.BELOW]: B.UP,
  [u.LEFT]: B.RIGHT,
  [u.RIGHT]: B.LEFT
}, ot = 200, st = 500, v = 2, n = 8, h = 16;
class W extends O.Component {
  constructor() {
    super(...arguments);
    t(this, "zone", {
      [C.FLOW]: I.COLUMN,
      [C.STANDING]: u.ABOVE,
      [C.SIDE]: z.CENTER,
      cutOff: 0,
      order: 0,
      [r.H]: 0,
      [r.W]: 0
    });
    t(this, "tooltipBodySize", {
      [r.H]: 0,
      [r.W]: 0
    });
    t(this, "targetBounds", {
      [R.X]: 0,
      [N.X]: 0,
      [R.Y]: 0,
      [N.Y]: 0,
      [r.H]: 0,
      [r.W]: 0
    });
    t(this, "windowBounds", {
      [R.X]: 0,
      [N.X]: 0,
      [R.Y]: 0,
      [N.Y]: 0,
      [r.H]: 0,
      [r.W]: 0
    });
    t(this, "bodyRef", O.createRef());
    t(this, "tipRef", O.createRef());
    t(this, "tipEl", null);
    t(this, "bodyEl", null);
    t(this, "tooltipNode", null);
    t(this, "hasTracked", !1);
    t(this, "exitingAnimationTimer1", null);
    t(this, "exitingAnimationTimer2", null);
    t(this, "checkLayoutInterval", null);
    t(this, "state", {
      exiting: !1,
      // для отслеживания того что анимация при закрытии тултипа в прогрессе.
      isOpen: this.props.isOpen,
      // для отслеживания открыт/закрыт ли tooltip.
      needRenderTooltip: this.props.isOpen,
      // нужно рендерить тултип или нет, признак анимационно зависимого рендериннга открыт/закрыт ли tooltip
      standing: u.ABOVE
    });
    // Открыть поповер
    t(this, "prepareOpen", () => {
      this.state.exiting && this.animateExitStop(), this.setState({ isOpen: !0, needRenderTooltip: !0 });
    });
    // Закрыть поповер
    t(this, "close", () => {
      this.setState({ isOpen: !1 });
    });
    // Метод начала отслеживания поповера и анимация его появления
    t(this, "enter", () => {
      this.trackTooltip(), this.animateEnter(), this.props.onShow && this.tooltipNode && this.props.onShow(this.tooltipNode);
    });
    // Метод окончания отслеживания поповера и анимация его исчезновения
    t(this, "exit", () => {
      this.animateExit(), this.untrackTooltip();
    });
    t(this, "setTooltipNode", (i) => {
      const { setTooltipRef: s } = this.props;
      i && (this.bodyEl = this.bodyRef.current, this.tipEl = this.tipRef.current), this.tooltipNode = i, s == null || s(this.tooltipNode);
    });
    // Рендер поповера
    t(this, "resolveTooltipLayout", () => {
      if (!this.tooltipNode)
        return;
      const { alignTip: i } = this.props, s = j(
        this.props.preferPlace,
        this.windowBounds,
        this.targetBounds,
        n,
        h,
        {
          h: this.tooltipBodySize.h + n,
          w: this.tooltipBodySize.w + n
        }
      );
      this.zone = s, this.setState({
        standing: s.standing
      });
      const o = q[s.flow], l = { ...this.tooltipBodySize };
      l[s.flow === I.ROW ? r.W : r.H] += n;
      const e = K(s, this.targetBounds, l);
      e[o.main.start] += v * s.order;
      let T = 0;
      this.bodyEl && (T = Math.round(+getComputedStyle(this.bodyEl).borderRadius.slice(0, -2)) || 0);
      const d = n + v, m = T * 2 + n * 2 + d, k = this.windowBounds[o.cross.start], A = this.windowBounds[o.cross.end], w = this.windowBounds[o.cross.size], c = w - d * 2, y = k + d, g = A - d, D = e[o.cross.start], F = e[o.cross.end];
      i === z.START ? e[o.cross.start] = this.targetBounds[o.cross.end] - h - n - this.targetBounds[o.cross.size] / 2 : i === z.END ? e[o.cross.start] = this.targetBounds[o.cross.start] - l[o.cross.size] + h + n + this.targetBounds[o.cross.size] / 2 : e.crossLength > w ? e[o.cross.start] = 0 : this.targetBounds[o.cross.end] < m ? e[o.cross.start] = this.targetBounds[o.cross.end] - m : this.targetBounds[o.cross.start] > g ? e[o.cross.start] = this.targetBounds[o.cross.start] - l[o.cross.size] : e.crossLength > c ? e[o.cross.start] = (w - e.crossLength) / 2 : D < y ? e[o.cross.start] = y : F > g && (e[o.cross.start] = e[o.cross.start] - (e[o.cross.end] - g)), this.tooltipNode.style.flexFlow = s.flow, this.bodyEl && (this.bodyEl.style.order = s.order.toString()), this.tooltipNode.style.top = `${e.y}px`, this.tooltipNode.style.left = `${e.x}px`;
      let E = Z(s.flow, G.CROSS, this.targetBounds, e) - n;
      E < h ? E = h : E > e.crossLength - h - n * 2 && (E = e.crossLength - h - n * 2), this.tipEl && (this.tipEl.style.transform = `${Q[s.flow]}(${E}px)`, this.tipEl.style.borderWidth = `${n}px`);
    });
    // Метод проверки изменения границ обернутого элемента.
    t(this, "setAndCheckResizeTargetBounds", () => {
      const { targetRef: i } = this.props;
      if (!i.current)
        return !1;
      const s = L(i.current);
      return this.targetBounds && J(this.targetBounds, s) ? !1 : (this.targetBounds = s, !0);
    });
    // Метод проверки необходимости перерисовки лейаута
    t(this, "checkTargetReposition", () => {
      this.setAndCheckResizeTargetBounds() && this.resolveTooltipLayout();
    });
    // Метод измерения размеров тела тултипа (без стрелочки)
    t(this, "setTooltipBodySize", () => {
      this.bodyEl && (this.tooltipBodySize = { w: this.bodyEl.offsetWidth, h: this.bodyEl.offsetHeight });
    });
    // Очистка таймеров анимации исчезновения
    t(this, "animateExitStop", () => {
      this.exitingAnimationTimer1 && window.clearTimeout(this.exitingAnimationTimer1), this.exitingAnimationTimer2 && window.clearTimeout(this.exitingAnimationTimer2), this.setState({ exiting: !1 });
    });
    // Анимация исчезновения
    t(this, "animateExit", () => {
      this.setState({ exiting: !0 }), this.exitingAnimationTimer2 = window.setTimeout(() => {
        window.setTimeout(() => {
          this.tooltipNode && (this.tooltipNode.style.transform = `${b[this.zone.flow]}(${this.zone.order * 50}px)`, this.tooltipNode.style.opacity = "0");
        }, 0);
      }, 0), this.exitingAnimationTimer1 = window.setTimeout(() => {
        this.setState({ exiting: !1, needRenderTooltip: !1 });
      }, st);
    });
    // Анимация появления
    t(this, "animateEnter", () => {
      this.tooltipNode && (this.tooltipNode.style.transform = `${b[this.zone.flow]}(${this.zone.order * 50}px)`, this.tooltipNode.style.opacity = "0", this.tooltipNode.offsetHeight, this.tipEl && (this.tipEl.style.transition = "transform 150ms ease-in"), this.tooltipNode.style.transitionProperty = "opacity, transform", this.tooltipNode.style.transitionDuration = "500ms", this.tooltipNode.style.transitionTimingFunction = "cubic-bezier(0.230, 1.000, 0.320, 1.000)", this.tooltipNode.style.opacity = "1", this.tooltipNode.style.transform = "translateY(0)");
    });
    //  Отслеживание поповера
    t(this, "trackTooltip", () => {
      this.tooltipNode && (this.hasTracked = !0, this.checkLayoutInterval = window.setInterval(this.checkTargetReposition, ot), window.addEventListener("scroll", this.onWindowScroll), window.addEventListener("resize", this.onWindowResize), this.windowBounds = L(window), this.setTooltipBodySize(), this.setAndCheckResizeTargetBounds(), this.resolveTooltipLayout());
    });
    // Отписка от отслеживания поповера
    t(this, "untrackTooltip", () => {
      this.tooltipNode && (this.checkLayoutInterval && window.clearInterval(this.checkLayoutInterval), window.removeEventListener("scroll", this.onWindowScroll), window.removeEventListener("resize", this.onWindowResize), this.hasTracked = !1);
    });
    // Перерисовка при скролле "рамки"
    t(this, "onWindowScroll", () => {
      this.setAndCheckResizeTargetBounds(), this.resolveTooltipLayout();
    });
    // Перерисовка при изменении размеров "рамки"
    t(this, "onWindowResize", () => {
      this.windowBounds = L(window), this.resolveTooltipLayout();
    });
    // Отрисовка самого Tooltip
    t(this, "tooltipRender", () => {
      const {
        className: i,
        size: s,
        preferPlace: o,
        alignTip: l,
        isOpen: e,
        renderContainer: T,
        onShow: d,
        setTooltipRef: m,
        onKeyDown: k,
        targetRef: A,
        ...w
      } = this.props, { elements: c } = this.context, y = s === U.SM ? f.tooltipSM : f.tooltipLG, g = $(
        f.tooltipDesktop,
        y,
        { [f.closable]: !!c.closeButton },
        i
      );
      return /* @__PURE__ */ x("div", { className: f.tooltipOverlay, children: /* @__PURE__ */ S("div", { className: g, ...w, ref: this.setTooltipNode, children: [
        /* @__PURE__ */ S("div", { className: f.tooltipDesktopContent, ref: this.bodyRef, children: [
          c.body,
          c.link,
          c.closeButton
        ] }),
        /* @__PURE__ */ x(V, { direction: tt[this.state.standing], ref: this.tipRef })
      ] }) });
    });
  }
  render() {
    const { renderContainer: i } = this.props, { needRenderTooltip: s } = this.state, { elements: o } = this.context;
    return /* @__PURE__ */ S(P, { children: [
      o.target,
      s && /* @__PURE__ */ x(Y, { container: i ?? document.body, children: this.tooltipRender() })
    ] });
  }
  componentDidMount() {
    this.props.isOpen && this.enter();
  }
  componentDidUpdate(i, s) {
    const o = this.props, l = this.state, e = !i.isOpen && o.isOpen, T = i.isOpen && !o.isOpen;
    if (e) {
      this.prepareOpen();
      return;
    } else if (T) {
      this.close();
      return;
    }
    const d = !s.isOpen && l.isOpen, m = s.isOpen && !l.isOpen;
    if (d) {
      this.enter();
      return;
    } else if (m) {
      this.exit();
      return;
    }
    l.isOpen && !M(i.children, o.children) && (this.setTooltipBodySize(), this.setAndCheckResizeTargetBounds(), this.resolveTooltipLayout());
  }
  componentWillUnmount() {
    this.animateExitStop(), this.hasTracked && this.untrackTooltip();
  }
}
t(W, "displayName", "TooltipBase"), t(W, "contextType", X);
export {
  W as TooltipDesktopBase
};
//# sourceMappingURL=TooltipDesktopBase.js.map
