var l = Object.defineProperty;
var h = (n, s, e) => s in n ? l(n, s, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[s] = e;
var o = (n, s, e) => h(n, typeof s != "symbol" ? s + "" : s, e);
import { jsx as d } from "react/jsx-runtime";
import u from "react";
import { TooltipDesktopBase as a } from "./components/TooltipDesktopBase.js";
import { TooltipContext as m } from "../../TootlipContext.js";
import { isKey as f } from "../../../../utils/keyboard.js";
class p extends u.Component {
  constructor() {
    super(...arguments);
    o(this, "tooltip", null);
    o(this, "timeout");
    o(this, "setTooltipRef", (e) => {
      const { toggleType: t } = this.props;
      e && t === "hover" && this.addHoverListeners(e), this.tooltip = e;
    });
    // Закрываем Tooltip при клике за его пределами.
    o(this, "closeIfOuterAction", (e) => {
      const { targetRef: t } = this.props, { setTooltipOpen: i } = this.context;
      if (t.current && this.tooltip) {
        const r = !t.current.contains(e.target), c = !this.tooltip.contains(e.target);
        r && c && i(!1);
      }
    });
    // Закрываем Tooltip по нажатию Esc
    o(this, "closeIfEscapeKey", (e) => {
      const t = e.code || e.keyCode;
      f(t, "ESCAPE") && this.context.setTooltipOpen(!1);
    });
    o(this, "addHoverListeners", (e) => {
      e.addEventListener("mouseenter", this.handleMouseEnter), e.addEventListener("mouseleave", this.handleMouseLeave);
    });
    o(this, "removeHoverListeners", (e) => {
      e.removeEventListener("mouseenter", this.handleMouseEnter), e.removeEventListener("mouseleave", this.handleMouseLeave);
    });
    o(this, "handleMouseEnter", () => {
      const { tooltipOpen: e, targetHoveredRef: t, setTooltipOpen: i } = this.context;
      e || (i(!0), t.current = !0), clearTimeout(this.timeout);
    });
    o(this, "handleMouseLeave", () => {
      const { setTooltipOpen: e } = this.context;
      this.timeout = window.setTimeout(() => {
        e(!1);
      }, 500);
    });
  }
  render() {
    const { children: e, toggleType: t, ...i } = this.props;
    return /* @__PURE__ */ d(a, { ...i, setTooltipRef: this.setTooltipRef });
  }
  componentDidMount() {
    const { toggleType: e, targetRef: t } = this.props;
    this.props.isOpen && (document.addEventListener("click", this.closeIfOuterAction), document.addEventListener("keydown", this.closeIfEscapeKey)), t.current && e === "hover" && this.addHoverListeners(t.current);
  }
  componentDidUpdate(e) {
    const { targetRef: t } = this.props, i = !e.isOpen && this.props.isOpen, r = e.isOpen && !this.props.isOpen;
    i && (document.addEventListener("mousedown", this.closeIfOuterAction), document.addEventListener("keydown", this.closeIfEscapeKey)), r && (document.removeEventListener("mousedown", this.closeIfOuterAction), document.removeEventListener("keydown", this.closeIfEscapeKey), this.props.toggleType === "hover" && this.removeHoverListeners(this.tooltip)), t.current && e.toggleType != this.props.toggleType && (this.props.toggleType === "hover" ? this.addHoverListeners(t.current) : e.toggleType === "hover" && this.removeHoverListeners(t.current));
  }
  componentWillUnmount() {
    const { toggleType: e, targetRef: t } = this.props;
    document.removeEventListener("mousedown", this.closeIfOuterAction), document.removeEventListener("keydown", this.closeIfEscapeKey), t.current && e === "hover" && this.removeHoverListeners(t.current), clearTimeout(this.timeout);
  }
}
o(p, "displayName", "TooltipDesktop"), o(p, "contextType", m);
export {
  p as TooltipDesktop
};
//# sourceMappingURL=TooltipDesktop.js.map
