import { ETooltipStartCoordinates as m, ETooltipSizeParameter as f, ETooltipEndCoordinates as O, ETooltipFlowTypes as d, ETooltipPreferPlace as x, ETooltipAlign as T, ETooltipTypeName as n, ETooltipAxesType as S } from "../enums.js";
const F = 8, H = (e, t) => e.h === t.h && e.w === t.w && e.x === t.x && e.y === t.y && e.x2 === t.x2 && e.y2 === t.y2, E = {
  column: {
    cross: {
      end: O.X,
      size: f.W,
      start: m.X
    },
    main: {
      end: O.Y,
      size: f.H,
      start: m.Y
    }
  },
  row: {
    cross: {
      end: O.Y,
      size: f.H,
      start: m.Y
    },
    main: {
      end: O.X,
      size: f.W,
      start: m.X
    }
  }
}, R = (e, t, r) => r[E[e][t].size] / 2, I = (e, t, r) => r[E[e][t].start] + r[E[e][t].size] / 2, M = (e, t, r, s) => I(e, t, r) - s[E[e][t].start], D = (e, t, r, s, o) => {
  const i = E[e][t];
  return r === T.CENTER ? I(e, t, s) - R(e, t, o) : r === T.END ? s[i.end] : r === T.START ? s[i.start] - o[i.size] : 0;
}, G = (e) => {
  if (e === window)
    return {
      h: e.innerHeight,
      w: e.innerWidth,
      x: 0,
      x2: e.innerWidth,
      y: 0,
      y2: e.innerHeight
    };
  const t = e.getBoundingClientRect();
  return {
    h: t.bottom - t.top,
    w: t.right - t.left,
    x: t.left,
    x2: t.right,
    y: t.top,
    y2: t.bottom
  };
}, p = (e) => (t, r) => t[e] >= r[e], C = p(f.W), L = p(f.H), g = (e, t) => C(e, t) && L(e, t), Y = (e, t, r, s, o, i) => {
  let a = r.y + (r.y2 - r.y) / 2;
  const l = t[O.Y] - a;
  l < a && (a = l);
  const N = a + i[f.H] - s - o - F, h = [
    {
      [n.SIDE]: T.START,
      [n.STANDING]: x.ABOVE,
      [n.FLOW]: d.COLUMN,
      h: r.y,
      order: -1,
      w: t.x2
    },
    {
      [n.SIDE]: T.END,
      [n.STANDING]: x.RIGHT,
      [n.FLOW]: d.ROW,
      h: N,
      order: 1,
      w: t.x2 - r.x2
    },
    {
      [n.SIDE]: T.END,
      [n.STANDING]: x.BELOW,
      [n.FLOW]: d.COLUMN,
      h: t.y2 - r.y2,
      order: 1,
      w: t.x2
    },
    {
      [n.SIDE]: T.START,
      [n.STANDING]: x.LEFT,
      [n.FLOW]: d.ROW,
      h: N,
      order: -1,
      w: r.x
    }
  ];
  h.forEach((c) => {
    c.cutOff = /* area */
    -Math.max(0, Math.min(c.w, i.w)) * Math.max(0, Math.min(c.h, i.h));
  }), h.sort((c, y) => (c.cutOff ?? 0) - (y.cutOff ?? 0));
  const W = h.filter((c) => g(c, i));
  if (e) {
    const c = W.filter((A) => A[n.STANDING] === e);
    if (c.length)
      return c[0];
    const y = h.filter((A) => A[n.STANDING] === e);
    if (!W.length && y.length)
      return y[0];
  }
  return W.length ? W[0] : h[0];
}, w = (e, t, r) => {
  const { main: s, cross: o } = E[e.flow], i = T.CENTER, a = D(e.flow, S.MAIN, e.side, t, r), l = r[s.size], N = D(e.flow, S.CROSS, i, t, r), h = r[o.size];
  return {
    [o.start]: N,
    crossLength: h,
    [o.end]: N + h,
    [s.start]: a,
    mainLength: l,
    [s.end]: a + l
  };
};
export {
  E as axes,
  G as calcBounds,
  w as calcRelPos,
  I as centerOfBounds,
  M as centerOfBoundsFromBounds,
  R as centerOfSize,
  g as doesFitWithin,
  H as equalCoords,
  Y as pickZone,
  D as place
};
//# sourceMappingURL=Positioning.js.map
