var N = Object.defineProperty;
var f = (c, n, e) => n in c ? N(c, n, { enumerable: !0, configurable: !0, writable: !0, value: e }) : c[n] = e;
var i = (c, n, e) => f(c, typeof n != "symbol" ? n + "" : n, e);
import { jsx as h } from "react/jsx-runtime";
import C from "react";
import { TreeView as g } from "../../TreeView/TreeView.js";
import { AccordionBase as u } from "../../AccordionBase/protected/AccordionBase.js";
import { c as y } from "../../../chunks/vendor-Ba_pyhza.js";
const T = "collapsableTreeNodeContent__b5393f54", b = {
  collapsableTreeNodeContent: T
};
class B extends C.Component {
  constructor() {
    super(...arguments);
    i(this, "state", {
      controlled: typeof this.props.opened < "u"
    });
    /**
     * Изменяет состояние ноды - раскрыта/свернута.
     * Эта функция передается дочерним компонентам и вызывается из них.
     */
    i(this, "toggle", ({ openedNode: e, setOpenedNode: r }) => (t) => {
      const { controlled: s } = this.state, { opened: l, toggle: o } = this.props;
      (s ? l : e) !== t && (s ? o == null || o(t) : r(t));
    });
    /** Render-функция для передачи дочерних нод. */
    i(this, "renderBody", (e) => (r) => {
      const { activeNode: t, openedNode: s, hasChildNodes: l } = e, { animating: o } = r, { opened: p, renderBody: d } = this.props, { controlled: a } = this.state;
      return e.hasChildNodes ? /* @__PURE__ */ h(g.Group, { children: d({
        activeNode: t,
        animating: o,
        hasChildNodes: l,
        opened: a ? p : s,
        toggle: this.toggle(e)
      }) }) : d({
        activeNode: t,
        animating: o,
        hasChildNodes: l,
        opened: a ? p : s,
        toggle: this.toggle(e)
      });
    });
    /** Render-функция не сворачиваемой части ноды. */
    i(this, "renderHeader", (e) => (r) => {
      const { activeNode: t, openedNode: s, hasChildNodes: l, isLastNode: o } = e, { animating: p } = r, { opened: d, renderHeader: a } = this.props, { controlled: m } = this.state;
      return a({
        activeNode: t,
        animating: p,
        hasChildNodes: l,
        isLastNode: o,
        opened: m ? d : s,
        toggle: this.toggle(e)
      });
    });
  }
  render() {
    const { opened: e, onToggle: r, renderBody: t, renderHeader: s, toggle: l, ...o } = this.props, { controlled: p } = this.state;
    return /* @__PURE__ */ h(g.Node, { opened: e, ...o, children: (d) => {
      const a = p ? e : d.openedNode;
      return /* @__PURE__ */ h(
        u,
        {
          expandAnimationClassName: y(b.collapsableTreeNodeContent, {
            collapsed: !a
          }),
          renderBody: this.renderBody(d),
          renderHeader: this.renderHeader(d),
          isOpen: a,
          onToggle: r
        }
      );
    } });
  }
}
i(B, "displayName", "CollapsableTreeNode");
export {
  B as CollapsableTreeNode
};
//# sourceMappingURL=CollapsableTreeNode.js.map
